{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/MelissaAU/Equipo2_JL_PPI2020/blob/master/Archivo%20colab\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# Método del Punto Fijo con error absoluto y relativo\n",
        "\n",
        "def punto_fijo(g, x0, tolerancia, iter_max):\n",
        "    \"\"\"\n",
        "    g: función de iteración g(x)\n",
        "    x0: valor inicial\n",
        "    tolerancia: error permitido\n",
        "    iter_max: número máximo de iteraciones\n",
        "    \"\"\"\n",
        "    print(f\"{'Iteración':^10} {'x':^15} {'Error Abs.':^15} {'Error Rel. (%)':^15}\")\n",
        "    print(\"-\" * 60)\n",
        "\n",
        "    for i in range(1, iter_max + 1):\n",
        "        x1 = g(x0)  # Calcular siguiente valor\n",
        "        error_abs = abs(x1 - x0)\n",
        "        error_rel = abs((x1 - x0) / x1) * 100 if x1 != 0 else 0\n",
        "\n",
        "        print(f\"{i:^10} {x1:^15.6f} {error_abs:^15.6e} {error_rel:^15.6f}\")\n",
        "\n",
        "        if error_abs < tolerancia:\n",
        "            print(\"\\n✅ Convergencia alcanzada\")\n",
        "            return x1\n",
        "\n",
        "        x0 = x1  # Actualizar valor\n",
        "\n",
        "    print(\"\\n❌ No se alcanzó la convergencia\")\n",
        "    return x1\n",
        "\n",
        "\n",
        "# Ejemplo de uso:\n",
        "import math\n",
        "\n",
        "# Ecuación: x = cos(x)\n",
        "def g(x):\n",
        "    return math.cos(x)\n",
        "\n",
        "# Parámetros iniciales\n",
        "x0 = 0.5\n",
        "tolerancia = 1e-6\n",
        "iter_max = 100\n",
        "\n",
        "raiz = punto_fijo(g, x0, tolerancia, iter_max)\n",
        "print(f\"\\nLa raíz aproximada es: {raiz:.6f}\")\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "55T9Ovtk5Z-_",
        "outputId": "4f89068e-180e-4088-86fc-f4b71faf96de"
      },
      "execution_count": 2,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Iteración         x          Error Abs.    Error Rel. (%) \n",
            "------------------------------------------------------------\n",
            "    1         0.877583      3.775826e-01      43.025304   \n",
            "    2         0.639012      2.385701e-01      37.334179   \n",
            "    3         0.802685      1.636726e-01      20.390637   \n",
            "    4         0.694778      1.079071e-01      15.531158   \n",
            "    5         0.768196      7.341780e-02      9.557173    \n",
            "    6         0.719165      4.903039e-02      6.817678    \n",
            "    7         0.752356      3.319031e-02      4.411518    \n",
            "    8         0.730081      2.227470e-02      3.050989    \n",
            "    9         0.745120      1.503928e-02      2.018369    \n",
            "    10        0.735006      1.011403e-02      1.376047    \n",
            "    11        0.741827      6.820214e-03      0.919381    \n",
            "    12        0.737236      4.590797e-03      0.622704    \n",
            "    13        0.740330      3.093926e-03      0.417912    \n",
            "    14        0.738246      2.083414e-03      0.282211    \n",
            "    15        0.739650      1.403724e-03      0.189782    \n",
            "    16        0.738705      9.454234e-04      0.127984    \n",
            "    17        0.739341      6.369129e-04      0.086146    \n",
            "    18        0.738912      4.290029e-04      0.058059    \n",
            "    19        0.739201      2.889948e-04      0.039096    \n",
            "    20        0.739007      1.946644e-04      0.026341    \n",
            "    21        0.739138      1.311310e-04      0.017741    \n",
            "    22        0.739050      8.833017e-05      0.011952    \n",
            "    23        0.739109      5.950083e-05      0.008050    \n",
            "    24        0.739069      4.008022e-05      0.005423    \n",
            "    25        0.739096      2.699863e-05      0.003653    \n",
            "    26        0.739078      1.818655e-05      0.002461    \n",
            "    27        0.739090      1.225070e-05      0.001658    \n",
            "    28        0.739082      8.252210e-06      0.001117    \n",
            "    29        0.739087      5.558793e-06      0.000752    \n",
            "    30        0.739084      3.744468e-06      0.000507    \n",
            "    31        0.739086      2.522319e-06      0.000341    \n",
            "    32        0.739084      1.699064e-06      0.000230    \n",
            "    33        0.739086      1.144510e-06      0.000155    \n",
            "    34        0.739085      7.709558e-07      0.000104    \n",
            "\n",
            "✅ Convergencia alcanzada\n",
            "\n",
            "La raíz aproximada es: 0.739085\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import numpy as np\n",
        "\n",
        "def jacobi(A, b, x0, tolerancia, iter_max):\n",
        "    \"\"\"\n",
        "    A: matriz de coeficientes\n",
        "    b: vector de términos independientes\n",
        "    x0: vector inicial\n",
        "    tolerancia: error máximo permitido\n",
        "    iter_max: número máximo de iteraciones\n",
        "    \"\"\"\n",
        "    n = len(A)\n",
        "    x = x0.copy()\n",
        "    print(f\"{'Iteración':^10} {'Valores de x':^40} {'Error Relativo (%)':^20}\")\n",
        "    print(\"-\" * 80)\n",
        "\n",
        "    for k in range(1, iter_max + 1):\n",
        "        x_nuevo = np.zeros_like(x)\n",
        "\n",
        "        # Fórmula del método de Jacobi\n",
        "        for i in range(n):\n",
        "            suma = 0\n",
        "            for j in range(n):\n",
        "                if i != j:\n",
        "                    suma += A[i][j] * x[j]\n",
        "            x_nuevo[i] = (b[i] - suma) / A[i][i]\n",
        "\n",
        "        # Cálculo del error relativo porcentual\n",
        "        error_rel = np.linalg.norm(x_nuevo - x, np.inf) / np.linalg.norm(x_nuevo, np.inf) * 100\n",
        "\n",
        "        print(f\"{k:^10} {str(np.round(x_nuevo, 6)):^40} {error_rel:^20.6f}\")\n",
        "\n",
        "        if error_rel < tolerancia:\n",
        "            print(\"\\n✅ Convergencia alcanzada\")\n",
        "            return x_nuevo\n",
        "\n",
        "        x = x_nuevo.copy()\n",
        "\n",
        "    print(\"\\n❌ No se alcanzó la convergencia\")\n",
        "    return x\n",
        "\n",
        "# Ejemplo de uso ---------------------------------------------\n",
        "\n",
        "# Sistema de ecuaciones:\n",
        "# 10x1 - x2 + 2x3 = 6\n",
        "# -x1 + 11x2 - x3 + 3x4 = 25\n",
        "# 2x1 - x2 + 10x3 - x4 = -11\n",
        "# 3x2 - x3 + 8x4 = 15\n",
        "\n",
        "A = np.array([\n",
        "    [10, -1, 2, 0],\n",
        "    [-1, 11, -1, 3],\n",
        "    [2, -1, 10, -1],\n",
        "    [0, 3, -1, 8]\n",
        "], dtype=float)\n",
        "\n",
        "b = np.array([6, 25, -11, 15], dtype=float)\n",
        "x0 = np.zeros(len(b))\n",
        "tolerancia = 1e-6\n",
        "iter_max = 100\n",
        "\n",
        "solucion = jacobi(A, b, x0, tolerancia, iter_max)\n",
        "print(f\"\\nSolución aproximada: {np.round(solucion, 6)}\")\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Mp9MsPBWE4d5",
        "outputId": "08dd3b85-65bc-49ad-8d79-602dec213037"
      },
      "execution_count": 3,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Iteración                Valores de x                Error Relativo (%) \n",
            "--------------------------------------------------------------------------------\n",
            "    1      [ 0.6       2.272727 -1.1       1.875   ]      100.000000     \n",
            "    2      [ 1.047273  1.715909 -0.805227  0.885227]      57.682119      \n",
            "    3      [ 0.932636  2.053306 -1.049341  1.130881]      16.431878      \n",
            "    4      [ 1.015199  1.953696 -0.968109  0.973843]       8.037995      \n",
            "    5      [ 0.988991  2.011415 -1.010286  1.021351]       2.869570      \n",
            "    6      [ 1.003199  1.992241 -0.994522  0.994434]       1.351080      \n",
            "    7      [ 0.998128  2.002307 -1.001972  1.003594]       0.502701      \n",
            "    8      [ 1.000625  1.99867  -0.999036  0.998888]       0.235453      \n",
            "    9      [ 0.999674  2.000448 -1.000369  1.000619]       0.088849      \n",
            "    10     [ 1.000119  1.999768 -0.999828  0.999786]       0.041665      \n",
            "    11     [ 0.999942  2.000085 -1.000068  1.000109]       0.016125      \n",
            "    12     [ 1.000022  1.999959 -0.999969  0.99996 ]       0.007442      \n",
            "    13     [ 0.99999   2.000016 -1.000013  1.000019]       0.002979      \n",
            "    14     [ 1.000004  1.999993 -0.999994  0.999992]       0.001337      \n",
            "    15     [ 0.999998  2.000003 -1.000002  1.000003]       0.000547      \n",
            "    16     [ 1.000001  1.999999 -0.999999  0.999999]       0.000241      \n",
            "    17     [ 1.        2.000001 -1.        1.000001]       0.000100      \n",
            "    18                [ 1.  2. -1.  1.]                   0.000044      \n",
            "    19                [ 1.  2. -1.  1.]                   0.000018      \n",
            "    20                [ 1.  2. -1.  1.]                   0.000008      \n",
            "    21                [ 1.  2. -1.  1.]                   0.000003      \n",
            "    22                [ 1.  2. -1.  1.]                   0.000001      \n",
            "    23                [ 1.  2. -1.  1.]                   0.000001      \n",
            "\n",
            "✅ Convergencia alcanzada\n",
            "\n",
            "Solución aproximada: [ 1.  2. -1.  1.]\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "import numpy as np\n",
        "\n",
        "def factorizacion_LU(A, b):\n",
        "    \"\"\"\n",
        "    Resuelve el sistema A·x = b usando factorización LU\n",
        "    A: matriz de coeficientes\n",
        "    b: vector de términos independientes\n",
        "    \"\"\"\n",
        "    n = len(A)\n",
        "    L = np.zeros((n, n))\n",
        "    U = np.zeros((n, n))\n",
        "    # Descomposición A = L · U\n",
        "    for i in range(n):\n",
        "        # Cálculo de elementos de U\n",
        "        for k in range(i, n):\n",
        "            suma = sum(L[i][j] * U[j][k] for j in range(i))\n",
        "            U[i][k] = A[i][k] - suma\n",
        "\n",
        "        # Cálculo de elementos de L\n",
        "        for k in range(i, n):\n",
        "            if i == k:\n",
        "                L[i][i] = 1\n",
        "            else:\n",
        "                suma = sum(L[k][j] * U[j][i] for j in range(i))\n",
        "                L[k][i] = (A[k][i] - suma) / U[i][i]\n",
        "\n",
        "    # Sustitución hacia adelante: L·y = b\n",
        "    y = np.zeros(n)\n",
        "    for i in range(n):\n",
        "        suma = sum(L[i][j] * y[j] for j in range(i))\n",
        "        y[i] = b[i] - suma\n",
        "\n",
        "    # Sustitución hacia atrás: U·x = y\n",
        "    x = np.zeros(n)\n",
        "    for i in range(n-1, -1, -1):\n",
        "        suma = sum(U[i][j] * x[j] for j in range(i+1, n))\n",
        "        x[i] = (y[i] - suma) / U[i][i]\n",
        "\n",
        "    return L, U, x\n",
        "\n",
        "# Ejemplo de uso ---------------------------------------------\n",
        "\n",
        "A = np.array([\n",
        "    [1, 1, 0, 3],\n",
        "    [2, 1, -1, 1],\n",
        "    [3, -1, -1, 2],\n",
        "    [-1, 2, 3, -1]\n",
        "], dtype=float)\n",
        "\n",
        "b = np.array([8, 7, 14, -7], dtype=float)\n",
        "\n",
        "L, U, x = factorizacion_LU(A, b)\n",
        "\n",
        "print(\"Matriz L:\\n\", np.round(L, 4))\n",
        "print(\"\\nMatriz U:\\n\", np.round(U, 4))\n",
        "print(\"\\nSolución del sistema:\\n\", np.round(x, 6))\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "HOhHRLTGMN4t",
        "outputId": "fc0d8a83-f712-4d7f-953d-181a5660118b"
      },
      "execution_count": 6,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Matriz L:\n",
            " [[ 1.  0.  0.  0.]\n",
            " [ 2.  1.  0.  0.]\n",
            " [ 3.  4.  1.  0.]\n",
            " [-1. -3.  0.  1.]]\n",
            "\n",
            "Matriz U:\n",
            " [[  1.   1.   0.   3.]\n",
            " [  0.  -1.  -1.  -5.]\n",
            " [  0.   0.   3.  13.]\n",
            " [  0.   0.   0. -13.]]\n",
            "\n",
            "Solución del sistema:\n",
            " [ 3. -1.  0.  2.]\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyNg5eWHHXml5rwQe41U6pm/",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}